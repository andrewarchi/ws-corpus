# Generate assembly.md

def wrap_code:
  if . == "" then "\"\"" else "`\(.)`" end;
def count_each:
  group_by(.) | sort_by(-length) |
  map((.[0] | wrap_code) + if length != 1 then " (\(length | tostring))" else "" end);

"# Whitespace assembly mnemonics

<!-- Generated by tools/generate_assembly.jq; DO NOT EDIT. -->

These are the mnemonics used by known Whitespace assembly dialects for
instructions, ranked by popularity.
",
(
  (["push", "dup", "copy", "swap", "drop", "slide",
    "add", "sub", "mul", "div", "mod", "store", "retrieve",
    "label", "call", "jmp", "jz", "jn", "ret", "end",
    "printc", "printi", "readc", "readi",
    "shuffle", "dumpstack", "dumpheap", "dumptrace" | {key:., value:[]}] |
    from_entries) as $keys |
  map(
    .assembly.mnemonics | select(. != null) |
    to_entries[] |
    .value |= (
      map(
        ascii_downcase |
        gsub("^(stack|arith|math|calc|heap|flow|io|[samchfi])[ \\._]"; "") |
        gsub("^mod\\."; "") |
        gsub("( ([.%lf]?<[a-z_]+>|<<[a-z_]+>>|_))+$"; "")) |
      unique)) |
  reduce .[] as $inst ($keys; .[$inst.key] += $inst.value) |
  to_entries[].value |
  "- " + (count_each | join(", "))
),
"
## Extensions
",
(
  map(.assembly.extension | select(. != null)) |
  "- " + count_each[]
),
(
  map(
    select(.tags != null) |
    select(.tags | contains(["assembler"]) or contains(["disassembler"])) |
    select(.assembly.mnemonics == null) |
    "- " + (.id // "“\(.name)” by " + (.authors|join(", ")))) |
  sort |
  if length == 0 then empty
  else "", "## Need documentation", "", .[] end
)
